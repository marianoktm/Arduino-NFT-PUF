<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Web3.js MetaMask Tutorial</title>
  <!-- import Web3.js -->
  <script src="https://cdn.jsdelivr.net/npm/web3@latest/dist/web3.min.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/5.7.2/ethers.umd.min.js"></script>
</head>

<body>
<!-- placeholders -->
<div id="provider"></div>
<div id="currentAccount"></div>

<div id="warn" style="color: red"></div>

<div>
  <button id="getCurrentAccountButton">Request MetaMask Accounts</button>
</div>

<h2>PUF Input</h2>
<label for="pufInput">Insert PUF here:</label>
<input type="text" id="pufInput" placeholder="0xABABAB...">
<label for="accountInput">Insert new NFT owner's public key here:</label>
<input type="text" id="accountInput" placeholder="0xabab...">
<button id="mintButton">Convert PUF and mint!</button>

<h3>Results:</h3>
<div id="transactionResult"></div>



<!-- scripts -->
<script type="module">
  let web3;
  let contract;

  let abiPath = "";
  let contractABI;
  let contractAddress = "";
  let abiArray = [];

  /**
   * "main"
   */
  if (window.ethereum) {
    initWeb3(); // Initialize Web3
    registerEvents(); // Register all events for the interface
  }
  else {
    document.getElementById('warn').innerHTML = "Please <a href='https://metamask.io/download/'>install MetaMask</a>.";
  }

  /**
   * Initializes the application by connecting it to MetaMask
   */
  async function initWeb3() {
    web3 = new Web3(window.ethereum);

    if (window.ethereum.isMetaMask) {
      document.getElementById('provider').innerText = 'Connected to Ethereum with MetaMask.';
    } else {
      document.getElementById('provider').innerText = 'Non-MetaMask Ethereum provider detected.';
    }

    try {
      await fetch('./config.json')
              .then(response => response.json())
              .then(data => readConfigJSON(data))
              .catch(error => {
                console.error('Error fetching config.json:', error);
              });
    }
    catch (error) {
      console.log("Error during JSON fetching: ", error);
    }

    try {
      await fetch(abiPath)
              .then(response => response.json())
              .then(data => readAbiJSON(data))
              .catch(error => {
                console.error('Error fetching abi:', error);
              });
    }
    catch (error) {
      console.log("Error during ABI fetching: ", error);
    }

    try {
      for (let key in contractABI) {
        abiArray.push([key,contractABI[key]]);
      }
      console.log("contractABI:", contractABI);
      //abiArray = JSON.parse(contractABI.toString());
      console.log("ABI: ", abiArray);
    }
    catch (error) {
      console.error('Abi conversion error: ', error);
    }
  }

  async function readConfigJSON(data) {
    console.log(data);
    abiPath = data.abi_path;
    console.log(abiPath);
    contractAddress = data.contract_address;
    console.log(contractAddress);
  }

  async function readAbiJSON(data) {
    //console.log(data);
    contractABI = data;
    console.log(contractABI);
  }

  /**
   * Insert here all the various events to track
   */
  async function registerEvents() {
    try {
      // Get current account on a button click
      document.getElementById('getCurrentAccountButton').addEventListener('click', getCurrentAccountHandler);
      // Verifica il proprietario dell'NFT
      //document.getElementById("checkNftOwnerButton").addEventListener("click", checkNftOwnerHandler);
      // Mint NFT con la PUF
      document.getElementById("mintButton").addEventListener("click", mintHandler);
      document.getElementById("checkNftOwnerButton").addEventListener("click", checkNftOwnershipHandler);
    }
    catch (error) {
      console.log("Error during event handlers registration: ", error);
    }

  }

  /**
   *  Event handler for the "click" event on the "requestAccountsButton" button.
   *  It gets all the MetaMask accounts and prints the account currently in use.
   */
  async function getCurrentAccountHandler() {
    await window.ethereum.request({ method: 'eth_requestAccounts' });
    const accounts = await web3.eth.getAccounts();
    document.getElementById('currentAccount',).innerText = `Current Account: ${accounts[0]}`;
  }

  /**
   *  Event handler for the "click" event on the "mintButton" button.
   *  It gets the PUF from the "pufInput" field, converts it into a SHA-256 digest and
   *  mints a new NFT from it.
   */



  async function mintHandler() {
    if (!window.ethereum) {
      alert("You must be connected to MetaMask first!");
      return;
    }

    const pufInput = document.getElementById("pufInput").value;
    if (!pufInput) {
      alert("Insert a valid PUF!");
      return;
    }

    const accountInput = document.getElementById("accountInput").value;
    if (!accountInput) {
      alert("Inserisci a valid account!");
      return;
    }

    const hashedPUF = ethers.utils.sha256(ethers.utils.toUtf8Bytes(pufInput));
    const formattedDeviceDigest = ethers.utils.arrayify(hashedPUF);
    //________

    const contractChatABI = [
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "initialOwner",
            "type": "address"
          }
        ],
        "stateMutability": "nonpayable",
        "type": "constructor"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "to",
            "type": "address"
          },
          {
            "internalType": "bytes32",
            "name": "deviceDigest",
            "type": "bytes32"
          }
        ],
        "name": "mint",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "bytes32",
            "name": "deviceDigest",
            "type": "bytes32"
          }
        ],
        "name": "ownerOfDevice",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "owner",
        "outputs": [
          {
            "internalType": "address",
            "name": "",
            "type": "address"
          }
        ],
        "stateMutability": "view",
        "type": "function"
      },
      {
        "inputs": [],
        "name": "renounceOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "inputs": [
          {
            "internalType": "address",
            "name": "newOwner",
            "type": "address"
          }
        ],
        "name": "transferOwnership",
        "outputs": [],
        "stateMutability": "nonpayable",
        "type": "function"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "previousOwner",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "newOwner",
            "type": "address"
          }
        ],
        "name": "OwnershipTransferred",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "from",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "to",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "Transfer",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "owner",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "approved",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "uint256",
            "name": "tokenId",
            "type": "uint256"
          }
        ],
        "name": "Approval",
        "type": "event"
      },
      {
        "anonymous": false,
        "inputs": [
          {
            "indexed": true,
            "internalType": "address",
            "name": "owner",
            "type": "address"
          },
          {
            "indexed": true,
            "internalType": "address",
            "name": "operator",
            "type": "address"
          },
          {
            "indexed": false,
            "internalType": "bool",
            "name": "approved",
            "type": "bool"
          }
        ],
        "name": "ApprovalForAll",
        "type": "event"
      }
    ];

    try {
      const arduinoNFTContract = new web3.eth.Contract(contractChatABI, contractAddress);
      const accounts = await web3.eth.getAccounts();
      const from = accounts[0];
      console.log(from);
      const latestBlock = await web3.eth.getBlock("latest");
      const baseFeePerGas = latestBlock.baseFeePerGas; // Base fee del blocco più recente
      const priorityFee = web3.utils.toWei('2', 'gwei'); // Priorità per il miner (es. 2 Gwei)
      const maxFeePerGas = Number(baseFeePerGas) + Number(priorityFee); // Massimo fee per gas

      const receipt = await arduinoNFTContract.methods.mint(accountInput, hashedPUF).send({
        from: from,
        gas: 10000000,
        maxFeePerGas: maxFeePerGas,
        maxPriorityFeePerGas: priorityFee
      });
      console.log("Receipt: ", receipt);
    } catch (error) {
      console.error("Receipt error:", error);
      alert("Receipt error");
    }

    //________
    try {
      document.getElementById('warn').innerHTML = `Puf: ${hashedPUF}, Owner: ${accountInput}`;
      alert("NFT successfully minted!");
    } catch (error) {
      console.error("Minting error:", error);
      alert("Transaction error. Check the console for more informations.");
    }
  }

  async function checkNftOwnerHandler() {
    if (!window.ethereum) {
      alert("You must be connected to MetaMask first!");
      return;
    }

    const pufInput = document.getElementById("pufInput").value;
    if (!pufInput) {
      alert("Insert a valid PUF!");
      return;
    }


    // Converte la PUF in SHA-256
    const hashedPUF = ethers.utils.sha256(ethers.utils.toUtf8Bytes(pufInput));
    const formattedDeviceDigest = ethers.utils.arrayify(hashedPUF);

    try {
      const owner = await contract.ownerOfDevice(formattedDeviceDigest);
      alert(`Device owner: ${owner}`);
    } catch (error) {
      console.error("Error during owner retrieval:", error);
      alert("Error: An NFT with this PUF may not be minted yet...");
    }
  }

  /**
   *  Event handler for the "click" event on the "mintButton" button.
   *  It gets the PUF from the "pufInput" field, converts it into a SHA-256 digest and
   *  mints a new NFT from it.
   */
  async function convertPufHandler() {
    const pufInput = document.getElementById("pufInput").value;
    if (!pufInput) {
      alert("Inserisci un valore PUF valido!");
      return;
    }

    // Converti la PUF in SHA-256 usando ethers.js
    const hashedPUF = ethers.utils.sha256(ethers.utils.toUtf8Bytes(pufInput));
    document.getElementById("sha256Result").innerText = `SHA-256: ${hashedPUF}`;

    // Formatta l'hash per il contratto Ethereum
    const formattedDeviceDigest = ethers.utils.arrayify(hashedPUF);
    document.getElementById("formattedResult").innerText = `Device Digest: ${ethers.utils.hexlify(formattedDeviceDigest)}`;

    // Copia negli appunti
    /*
    navigator.clipboard.writeText(ethers.utils.hexlify(formattedDeviceDigest))
            .then(() => alert("Hash copiato negli appunti!"))
            .catch(err => console.error("Errore nel copiare:", err));
     */
  }

  async function mint(pufHash, ownerPrivateKey) {

  }

  async function getOwner(pufHash) {

  }

</script>
</body>
</html>